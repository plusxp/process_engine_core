# Process Engine Execution PoC

## FlowNodeHandlerFactory

Inside the factory, the mapping between types of BPMN-elements and their respective handlers is done.

Besides just mapping and creating regular handlers for FlowNodes, the factory also creates additional handlers if there are any BoundaryEvents attached to a FlowNode.

If this is the case, additional handlers will be chained to the original handlers using the decorator pattern.

Example:

The FlowNode is a ScriptTask and there are to BoundaryEvents attached to it:
* a TimerBoundaryEvent
* and an ErrorBoundaryEvent

The factory will create three handlers in this scenario. Calling execute on the handler that is returned by the factory, would result in the following call stack:

* TimerBoundaryEventHandler.execute
  * ErrorBoundaryEventHandler.execute
    * ScriptTaskHandler.execute

The order in which the BoundaryEvent-handlers are decorated around the original handler is also important.

In this case the TimerBoundaryEvent-handler has to start its timers as fast as possible.
If the ScriptTask encounters an error, the ErrorBoundaryEvent-handler has to have the ability to handle it and decide which FlowNode to execute next. On the other hand the ErrorBoundaryEvent-handler would not want to handle an error that related to the TimerBoundaryEvent.

The factory ensures an order like this in a way that prevents conflicts.  However, the original FlowNodeHandler (in this case the ScriptTaskHandler) will always be called last in this chain.

## FlowNodeHandler

The FlowNodeHandler is the base class for all handlers. It provides an abstract `executeIntern`-method for the derived handler to implement its logic.

The base class also offers a private hook that is executed after each FlowNode execution, that is not exposed to derived classes.

## ProcessTokenFascade

The ProcessTokenFascade serves to identify the real use cases for a ProcessToken we currently need instead of just passing around the actual token as an object.

Every result that a FlowNode execution produced is saved via the fascade using the method `addResultForFlowNode`.

With a list of results like this, the old token format can be generated by using the method `getOldTokenFormat`. This is merely implemented for compatibility reasons and can later be used to identify all places that still rely on the old ProcessToken concept.

Another compatibility feature is the evaluation of mappers on FlowNodes or on SequenceFlows. These can be evaluated using `evaluateMapperForFlowNode` or `evaluateMapperForSequenceFlow`.

The splitting and merging of ProcessTokens is also done via the fascade using `getProcessTokenFascadeForParallelBranch` and `mergeTokenHistory`.

## ProcessModelFascade

Whenever an element of the process model is needed in a specific context, it is queried for using the ProcessModelFascade.

### SubProcessModelFascade

In case of the SubProcess, the queries handlers want to be answered during execution might be the same as usually.

But some of the queries need to be evaluated on another data set, that is the FlowNodes and the SequenceFlows that are encapsulated in the SubProcess itself, rather than in the normal Process.

Because of this, the SubProcessModelFascade is created using the original ProcessModelFascade (so that it can also access the process model).

The SubProcessModelFascade implements the same `IProcessModelFascade` interface as the normal fascade, so that it can be passed through to handlers without them knowing they're executed inside a SubProcess.

## ExecutionContextFascade

To get a better understanding of the use cases where we actually use the ExecutionContext, it is also represented by a fascade.
